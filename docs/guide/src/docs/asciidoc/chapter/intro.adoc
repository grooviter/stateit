== Intro

StateIT executes defined tasks and stores their state so that it knows when a given task has been executed successfully and there is no need to execute it again.

For example, here you have a Groovy script executing two different task, the first one creates a directory and the second one compresses all files inside the former directory inside a tar.gz file.

```groovy
@Grab('com.github.grooviter:stateit-files:1.0.0')
import com.github.grooviter.stateit.DSL.*

def plan = stateit {
   mkdir("sample-directory") {
      path = "/tmp/sample-directory"
   }

   state {
      provider = fileState("/tmp/example-state.json")
   }
}

apply(plan)
```

If you execute the script:

```
[mario@fedora stateit-cli-1.0.0]$ ./bin/stateit-cli --plan /tmp/myplan.st execute
[stateit] - 17:23:19.819 - state file found... loading resources
[stateit] - 17:23:19.863 - TO APPLY:     1
[stateit] - 17:23:19.863 - TO REMOVE:    0
[stateit] - 17:23:19.869 - saving state
```

You can check that the task created a directory. Now if you execute the same script one more time, you'll realize that the script doesn't execute anything:

```
[mario@fedora stateit-cli-1.0.0]$ ./bin/stateit-cli --plan /tmp/myplan.st execute
[stateit] - 17:23:19.819 - state file found... loading resources
[stateit] - 17:23:19.863 - TO APPLY:     0
[stateit] - 17:23:19.863 - TO REMOVE:    0
[stateit] - 17:23:19.869 - saving state
```

That's because the state stored in the `/tmp/example-state.json` path has registered the state of the script and it knows the task have been already applied